% SPDX-FileCopyrightText: 2023 Oscar Bender-Stone <oscarbenderstone@gmail.com>
% SPDX-License-Identifier: CC-BY-4.0
% 4-spec.tex - Specifices the Welkin language and provides a theoretical framework
% for general implementations

% TODO: create a version for welkin-standard.tex that directly includes the copyright notice
% Henceforth, compliant Welkin implementations will be collectively referred to as ``Welkin.'' A formal definition of

This standard requires a cursory background in discrete mathematics, parsing, and Backus-Naur Form (BNF). A reading of [] and [] suffices to understand this document.

This edition of the standard, in English, is the basis for all other translations. Only the grammars will be given in english and should be copied identically. However, any terms in this document may be translated or changed as necessary.

\section{Preliminaries}

% Helpful macros for terms for character encoding in math mode
\newcommand*{\chars}{\mathrm{CHAR}}
\newcommand*{\numbers}{\mathrm{NUMBER}}
\newcommand*{\whitespaces}{\mathrm{WHITE\_SPACES}}
\newcommand*{\reserved}{\mathrm{RESERVED}}
\newcommand*{\strings}{\mathrm{STRING}}
\newcommand*{\term}{\mathrm{term}}
\newcommand*{\terms}{\mathrm{terms}}
\newcommand*{\delimiters}{\mathrm{DELIMITERS}}
\newcommand*{\escapes}{\mathrm{ESCAPE}}
\newcommand*{\encoding}{\mathcal{E}}
\newcommand*{\decoding}{\mathcal{D}}


\newcommand*{\scope}{\textrm{scope}}

\SetBNFConfig{
  relation = {::=|=>},
  relation-sym-map = {
    {::=} = {=},
    {=>} = {->},
    {<~} = {},
  }
}

\subsection{Character Encodings}
% TODO: generalize to byte encodings and numbers.
In a formalist fashion, we define text, character encodings, and character decodings as generalized notions. The discussion here may be carried out in terms of bytes and specific data formats, but these concepts are beyond the scope of this standard.

Let Char be an arbitrary, finite set. An \textbf{encoding} is an injective mapping $\encoding : \mathbb{N} \to \textrm{Char}.$ The associated \textbf{decoding} is the left-inverse $\decoding: \mathrm{Char} \to \mathbb{N}$ of $\encoding.$ There is a natural extension $\decoding^{*}: \textrm{Char}^{*} \to \mathbb{N}^{*}$
that maps sequences in Char componentwise to sequences in $\mathbb{N}^{*}.$
We denote $\chars = \decoding(\textrm{Char})$ and CHAR* as the
Kleene-closure of CHAR, whose elements $w$ are called \textbf{words.}\footnote{Traditionally, the Klenne-closure of a set $A$ is denoted by $A^{*}.$ However, to ensure our BNF
  can be written in pure ASCII, we append $*$ without a superscript on $\chars$ and its subsets.} A word $w_{1}$ is a $b$-\textbf{separated} \textbf{subword} of $w_{2},$ denoted $w_{1} \subseteq_{b} w_{2},$ if $bw_{1} \subseteq w_{2}$ or $w_{1}b \subseteq w_{2}.$ In particular, if $b = \emptyset,$ then we simply call $w_{1}$ a \textbf{subword} of $w_{2}.$

Character encodings may be given as finite tables, matching natural numbers with characters. Several major encodings are defined in the following sources.
% TODO: put these references in bibtex
% US-ASCII (see references therein): https://www.iana.org/assignments/character-sets/character-sets.xhtml
% UTF-8, UTF-16: https://www.unicode.org/versions/Unicode15.0.0/UnicodeStandard-15.0.pdf
\begin{itemize}
	\item US-ASCII []. We will refer to this as ASCII, but there are subtle variations accross specific nationalities and applications (see []).
	\item UTF-8, UTF-16 []. % TODO write notes about both
\end{itemize}
Although ASCII is a subset of UTF-8, this standard will prioritize ASCII as much as possible.Every BNF grammar (see Section ?.?) for this standard will be written in ASCII as a unifying encoding, but users may create grammars using UTF-8 or their own encodings (see Section ?.?).
% TODO: put this into table format. We need an easy way to reference any of these sets and notes about them
% Defining each subimage linearly is not working that well.
We list several secondary notions in Table ?.? All of these sets, except STRING, are arbitrary.
% TODO: center text in the first row!
\begin{center}
  \bgroup
  \def\arraystretch{2.0}
\begin{tabular}{| c | c | c |}
  \hline
  \textbf{Set} & \textbf{Definition} & \textbf{Member Notation} \\
  \hline
  NUMBERS & Subset of $\chars*$ & $r$ \\
  \hline
  WHITE\_SPACES & Subset of $\chars*$ & $ws$ \\
  \hline
  DELIMITERS & Subset of $(\chars*)^{2}$ & $d = (d_{1}, d_{2})$ \\
  \hline
  STRING($d$) & \makecell{$s = d_{1}wd_{2},$ $d_{1}, d_{2} \not \subseteq_{ws} w.$ \\ $w$ is the \textbf{contents of} $s$ } & \makecell{$s_{d},$ with \\ contents $\hat{s}_{d}$} \\
  \hline
  STRING & Subset of $\bigcup \strings(d)$ & \makecell{$s,$ with \\ contents $\hat{s}$} \\
  \hline
  $D_{\strings}$ & \makecell{Set of delimiters \\ appearing in $\strings$} & \makecell{$d_{\strings}$} \\
  \hline
  ESCAPE$(W)$ & Subset of $\chars*\setminus W$ & $escape_{W}$ \\
  \hline
  ESCAPE & Subset of $\bigcup \escapes(d)$ & $escape$ \\
  \hline
\end{tabular}
\egroup
\end{center}

% Strings may include their delimiters by using $\escapes(\{d_{1}, d_{2}\})$ as a prefix or suffix.

We implicitly assume that $\chars*$ does not conflict with literals defined in a given standard grammar. In terms of the recommended LALR parser, this means that literals are matched first, not identifiers. However, these characters may be used by creating a custom grammar (see Section ?).


\subsection{BNF Variant}
Our variant of BNF uses the notation in Table ?.?. Our notation, as well as eevery standard Welkin grammar, is written in ASCII, but the interpreter may support additional encodings. (See Section ?.?).


Each BNF has an associated subset $\reserved \subseteq \chars*$ for any literals that appear in the grammar. We will explicty state these for standard Welkin grammars in the next section.

% TODO: fix spacing issues with Contaenation rows
\begin{center}
  \begin{tabular}{ | c | p{2cm} | p{6cm} | }
  \hline
  \textbf{Concept} & \textbf{Notation} & \textbf{Example} \\
  \hline
	Rule Assignment & $=$ & \begin{bnf} term ::= atom\end{bnf}\\
  \hline
  Empty Word & $\varepsilon := \emptyset$ & \begin{bnf} term ::= $\varepsilon$ \end{bnf} \\
    \hline
  \makecell{Concatenation \\ (No white spaces \\ inbetween rules)} & \makecell{Separate with \\  a period (.)}&  \begin{bnf} function ::= name.'('.number.')'\end{bnf} \\
  \hline
  \makecell{Concatenation \\ (White spaces \\ allowed)} & \makecell{Separate with \\ white space} & \begin{bnf} data ::= date name\end{bnf} \\
    \hline
    Groupings & Parantheses () & \begin{bnf} boolean ::= (true || false)\end{bnf} \\
    \hline
    Literals & ``word'' & \begin{bnf} boolean ::= `true' || `false' \end{bnf} \\
    \hline
  Choice Names & terms $\to$ rule & \makecell{\begin{bnf} boolean ::= `true' $\to$ true || `false' $\to$ false \end{bnf}, \\ equivalent to \\ \begin{bnf}  boolean ::= true // false ;; true ::= `true' ;; false ::= `false' \end{bnf}} \\
    \hline
\end{tabular}
\end{center}
% TODO: convert this into a table for easy access
% \begin{itemize}
%   \item $::=$ denotes rule assignment,
%   \item \texttt{term ::= $S \subseteq \chars^{*}$} means \texttt{term $\in S$},
%   \item $|$ denotes alternation,
% 	\item In a given choice, an arrow $\to$ denotes a new rule name. For example, the rule
% 		\begin{bnfgrammar}
% 			term ::= `A' $\to$ A | `B' $\to$ B
% 		\end{bnfgrammar}
% 		is equivalent to
% 		\begin{bnfgrammar}
% 			term ::= A || B ;;
% 			A ::= `A' ;;
% 			B ::= `B'
% 		\end{bnfgrammar}
% 	\item \texttt{term*} means 0 or more instances and is shorthand for
% 	\begin{center}
% 		\texttt{terms ::= term terms | term | $\varepsilon$},
% 	\end{center}
% 	\item \texttt{term+} means 1 or most one instances and is shorthand for
% 	\begin{center}
% 		\texttt{terms ::= term terms | term},
% 	\end{center}
%   \item Elements of CHAR* are included in quotes. To avoid confusion, literal quotes are denoted with ['].
% \end{itemize}
\section{The Welkin Language}

There are three fundamental variants of Welkin that define the foundation for the language:
\begin{itemize}
	\item Base Welkin, mirroring the key properties of the core data structure.
	\item Attribute Welkin, extending Base Welkin with attributes. Attributes are a limited type of directive that can customize how the interpreter accepts or presents data.
	\item Binder Welkin, enabling arbitrary evaluation of Welkin files and access to the user's operating system. This is equivalent to Attribute Welkin with two new directives: \texttt{@eval} and \texttt{@exec}. \end{itemize}
Each of these variants can be parsed with LALR parsers and fundamentally have the same semantics. However, in Binder Welkin, \texttt{@eval} makes the interpreter Turing complete (see Section ?.?), and using \texttt{@exec} can significantly impact the user's system. For this reason, Binder Welkin is a separate, optional component, as detailed in the Section ?.?
% \begin{itemize}
% 	% \item First Define character encodings in general. Helpful reference: \url{https://www.w3.org/International/questions/qa-what-is-encoding}
% 	%       \begin{itemize}
% 	% 	      \item For wide spread use, there should be different character encodings used for \textit{direct comparison} with Welkin files. Ultimately, every Welkin file will be converted into a standard binary (or possibly text) file to store the object
% 	%       \end{itemize}
% 	\item Determine a suitable BNF for Welkin, which can be parsed with LALR (or otherwise a more efficient parser)
% 	      \begin{itemize}
% 		      \item Key goal: make Welkin's syntax fully decidable and efficient to parse. An important component of CFLT called the Semantics Lifting Lemma (TBD) essentially says we can embed a complex syntax into a semantics. (This proof will hopefully be constructive and work for any random syntax, no matter how crazy it might be). In other words, using an efficient parser does NOT limit how expressive Welkin is.
% 		      \item Presuming the result above, there will be two variants: the finite (regex) and full versions.
% 		            \begin{itemize}
% 			            \item The finite, or regex, version is purely for regex-definable files.
% 			            \item The full version will be LALR parsed, as it is generally a standard for programming languages. Not only is it efficient (both in speed and memory), but any grammar written in LALR is unambiguous (reference needed!).
% 			            \item Now that the idea of these two versions is solidifed, we need some common terms. Most of these should come from graphviz, but also in other note taking formats.
% 		            \end{itemize}
% 		      \item The standard format should read just like an ordinary programming language. It may be akin to graphviz, but it should prioritze on the contents of each node and edge, not necessarially how they are rendered. (A better thought would be to put rendering information in a standard \textit{library}, which could then be minimized when browsing through a Welkin file/project.)
% 		            \begin{itemize}
% 			            \item Welkin essentially needs the key elements from set theory: conjunction, disjunction, negation, implication, etc. We can use corresponding symbols for these: $\&\&, ||, \neg, \rightarrow$. In \textit{customizable files}, these symbols can be overloaded and added upon.
% 			            \item Key goal: make this FULLY compatible with dot. (In fact, for a prototype, we can work with dot directly, but we should make it helpful for our needs).
% 									\item Another important point: we want to say that graph ALWAYS refers to a metagraph (to avoid redundancy)		            \end{itemize}
% 	      \end{itemize}
% 	\item Following CFLT, explain a suitable semantics for Welkin.
% 	      \begin{itemize}
% 		      \item We need to determine how to implement all of the axioms.
% 		      \item We also need to use a suitable proof system (e.g., Hilbert, Gentzen, etc.). Maybe that could be decided in CFLT?
% 	      \end{itemize}
% \end{itemize}
% TODO: figure out how to handle references to self. Is a separate keyword 'self' needed?
%\renewcommand{\syntleft}{\normalfont\bfseries}
%\renewcommand{\syntright}{}

% TODO: directly convert this into other grammars, such as lark.
% There should be some consistent procedure to ensure that the BNF here
% is the same as those found in any implementation
% Interesting idea: when there is a node A that should connect to other nodes B_1, B_2, ..., B_n,
% we require that the latter nodes be wrapped in their own graph. That way, we can stay consistent with
% GraphViz notation (for possible compatiblity reasons), but at the same time, we can keep track of the out-neighbors (out going
%\renewcommand{\bnfexpr}{\textbf}
\subsubsection*{Syntax}
Set each $\reserved$ set as follows. % TODO: figure out better way to display these! Hard to read delimiters!
\begin{itemize}
\item $\reserved_{\textrm{base}} = \{\{, \}, ., -, ->, <-\},$
\item $\reserved_{\textrm{attribute}} = \{\{, \}, (, ), [, ], ., -, ->, <-, @\},$
\item $\reserved_{\textrm{binder}} = \reserved_{\textrm{attribute}}.$
\end{itemize}
Each grammar is provided in Table 3.?.
% TODO; figure out rule for when NUMBERS is empty
% TODO: make different RESERVED key words for Base and Attribute Welkin. Binder Welkin is fairly straightforward
% (We actually only need to look at prefixes; any attribute names WILL be parsed first. Welkin will assume
% the user wanted the built-in directives. A different name for those should be used)
% TODO: It may be better to type up Welkin in regular font; it looks readable and could be done well in math mode.

% \SetBNFConfig{

%   relation-sym-map = {
%     {::=} = {\ensuremath{=}},
%   }
%   }
%     TODO: Remove Notes column
% TODO: add -> back into the grammar; using -> directly conflicts with simplebnf
\begin{table}[hbt!]
  \centering
    \begin{tabular}{| p{1.5cm} | p{9.5cm} |}%{1\textwidth}{| l | X |}
    \hline
    Variant & Grammar \\\hline % & Notes \\
      \makecell{Base \\ Welkin} &
  \begin{bnf}
  terms ::= term* ;;
  term ::= (graph | connections | member | unit) ;;
  graph ::= unit? ``\{'' terms ``\}'' ;;
  connections ::= term (connector term)+ ;;
	connector ::=
   | ``-'' term ``-'' $\to$ edge
   | ``-'' term ``>'' $\to$ left\_arrow
	 | ``<-'' term `-' $\to$ right\_arrow ;;
  member ::= unit? (`.'.(ident // string)? // `\#'.num )+ ;;
	unit ::= ident // string // num ;;
  ident ::= CHAR* ;;
	string ::= STRING ;;
	num ::= NUMBER
\end{bnf} \\ %& If $\numbers = \emptyset,$ any instance of \texttt{num} should be removed from the parser. \\
   \hline
      Attribute Welkin &
  % TODO: decide how to make import and override statements a part of bnf
  \makecell{import grammars/base.txt \\ override term}
  \begin{bnf}

  term ::= ``@''.(directive // graph[directive]) | construct | term ;;
  directive ::= attribute | alias ;;
  alias ::= unit ``\:='' (unit // graph);;
  attribute ::= ``import'' tuple $\to$ import
  | ``self'' $\to$ self
  | ``parse''.(graph // unit) $\to $ parse
  | ``validate''.tuple $\to$ validate
  | ``metadata''.graph[unit] $\to$ metadata
  | ``record''.term $\to$ record
  | ``render''.graph $\to$ render ;;

  construct ::= operation // tuple // list ;;
  operation ::= term.tuple // term unit term ;;
  tuple ::= ``('' term ``,'' (term ',')* ','? ``)'' ;;
  list ::= ``['' term ``,'' [term ',']* ``,''? ``]''
 \end{bnf} \\
                      %& This is limited to the CLI and GUI (TBD). \\
   \hline
   Binder Welkin &
\makecell{import grammars/attribute.txt \\ override directives}
    \begin{bnf}
     directives ::= attributes // binders ;;
     binders ::= ``eval''.tuple[unit] $\to$ eval
     | ``exec''.tuple[string] $\to$ exec
   \end{bnf} \\ %& Intended for use by programmers, mathematicians, and scientists.\\
    \hline
    \end{tabular}
  \end{table}

An acceptable parser for all three grammars should include the ability to compose and override rules. This ensures that any updates to grammars, if necessary, are isolated.

Throughout this document, Welkin documents are formatted with the following convention: the ASCII sequence \texttt{->} is rendered as $\to$ (A graphical user interface may support this rendering via glyphs). % TODO: put special renderings in a table
  % TODO: figure out suitable grammar composition notation
% Finally, Binder Welkin is given by the BNF in Attribute Welkin composed by two new directives. In BNF, these are appended to the directives rule:
% \begin{itemize}
% 	\item \texttt{},
% 	\item \texttt{}.
% \end{itemize}
% We explain the semantics for these directives in Section ?.?

% TODO: recognize, in cflt, that the above welkin file is in fact a context free grammar! The more important part, which we need to still define, is the semantics, which will have its full strength with the full grammar. (Maybe we should change that option to be semantics instead?)

\subsubsection*{Semantics}
We break down our semantics first by terms. Directives are handled separately in the next section.
% TODO: make this more efficient. (Probably best to follow the structure from a logic textbook)
\begin{definition}
Equality of terms.
\begin{itemize}
    % TODO: decide if ''A`` is the same as A
  \item \textbf{Basis.} Two units are equal if they are the same kind and obey one of the following.
	\begin{itemize}
	  \item \texttt{ident} terms are equal if their corresponding characters are equal,
      \item \texttt{string} terms are equal if their corresponding contents are equal. Thus, \texttt{``A''} coincides with \texttt{'A'},
	  \item \texttt{num} terms are equal if they represent the same value. Thus, \texttt{1} coincides with \texttt{10E}.
	\end{itemize}
  \item \textbf{Recursion.}
        \begin{itemize}
        \item Two members are the same if they contain the same list of units. % TODO: include the case of relative imports
        \item Two connectors are equal if they are equal as terms. %TODO: rework to make this clearer
 		  \item Two connections are equal if they connect the same terms and have equal connectors.
		  \item Two graphs are equal if they contain the same terms.
	\end{itemize}
\end{itemize}
\end{definition}
% This definition should be unnecessary; this should be clear from the BNF.
% \begin{definition} (Membership) Let $t$ be a term and $G$ a graph. We say $t$ is a \textbf{member} of $G$ if $t$ appears as the contents of $G.$\end{definition}
% \end{definition}
A \textbf{scope} is recursively defined and intutively is a level of terms.
\begin{definition} (Scope)
 Let $t$ be a term.
  \begin{itemize}
	\item If $t$ is not contained in a graph, then $\scope(\texttt{term}) = 0,$
	\item If $G' \in G$ are both graphs and $\scope(G') = n,$ then for all $t \in G',$ $\scope(t) = \scope(G) + 1.$
\end{itemize}
\end{definition}
A \textbf{valid} base Welkin file consists satisfies a unique naming rule: in every scope, there are no name collisons. In particular, every graph must \textbf{only be defined once.} Note that, by the way equality was defined between two numbers,
  there can only be one representation of a given number in a scope. For example, using \texttt{1} and \texttt{10E-1} in the same scope would produce a name collison.
\\ We first form an Abstract Syntax Tree (AST), from which we form the final stored data in a \textbf{Welkin Information Graph.}
\begin{definition}
  Base Welkin is parsed into the following AST $\mathcal{A}.$
  \begin{itemize}
	\item Every term is a new subtree with its contents as children.
    \item Every graph is an ordered pair of its aliases and list of children.
    % TODO: how to deal with empty connectors? Big issue for parsing and storing in a WIG!
    \item Every connection is an ordered pair:
		  \begin{itemize}
			\item Left arrows $u \xrightarrow{e} v$ correspond to a triple $(u, e, v);$
			\item Right arrows $u \xrightarrow{e} v$ correspond to the triple $(v, e, u);$
			\item Edges correspond to both a left and right arrow.
		  \end{itemize}
	\item Every unit is converted into its corresponding encoding via $\encoding^{*}.$
  \end{itemize}
 \end{definition}
 % TODO: talk about encoding of numbers in the structure itself. This probably a separate encoding from the one used to write the welkin file
 % TODO: determine best term for 3-uniform hypergraph
  % TODO: decide whether this should be defined only with ternary relations. It would be a bit messy to handle
  % nested relations, but I think this is a much better approach that trying to include some intuition about
  % category theory here. Categories are essential for understanding structures made in Welkin, but the standard
  % needs to be relatively simple and, most importantly, accessible.
% \begin{definition}
% 	A \textbf{Welkin Information Graph (WIG)} $\mathcal{G} = (G, L, \{t, s, c, i, l\})$ consists of
%   \begin{itemize}
%     \item a sequence $G = (G_{0}, G_{1}, \cdots, G_{n})$ of sets called \textbf{layers}, whose contents are \textbf{cells,}
%     \item a set $L$ of \textbf{labels} or \textbf{aliases},
%     \item a family of functions $s_{k}, t_{k}, c_{k}: G_{k+1} \to G_{k}$ called the \textbf{source, target,} and \textbf{connector maps,} respectively, and
%     \item a family of injective functions $i_{k}, l_{k}: G_{k} \to G_{k+1}$ called the \textbf{embedding} and \textbf{labeling maps,}
%    \end{itemize}
%   that obey the following equations:
%   \begin{itemize}
%     \item $s_{k} \circ c_{k + 1} = s_{k} \circ s_{k+1} = s_{k} \circ t_{k+1},$
%     \item $t_{k} \circ c_{k + 1} = t_{k} \circ s_{k+1} = t_{k} \circ t_{k+1},$
%     \item $c_{k} \circ c_{k + 1} = c_{k} \circ s_{k+1} = c_{k} \circ t_{k+1},$
%     \item $s_{k} \circ i_{k} = \textrm{id}_{G_{k}} = t_{k} \circ i_{k} = c_{k} \circ i_{k}.$
%   \end{itemize}
%   Graphically, this definition can be displayed as a diagram
% \begin{equation*}
%   \begin{tikzcd}
%   G_0 \arrow[r,"i_{0}"'] &
%   G_1 \arrow[r, "i_k"] \arrow[l, "s_0"', bend right] \arrow[l, "t_0", bend left] \arrow[l, "c_0"] &
%   G_2 \arrow[r, "i_k"] \arrow[l, "s_k"] \arrow[l, "t_k"] \arrow[l, "c_k"] &
%   \cdots \arrow[r, "i_k"] \arrow[l, "s_k"] \arrow[l, "t_k"] \arrow[l, "c_k"] &
%   G_n &
% \end{tikzcd}
% \end{equation*}
% where the following diagrams commute (i.e., their composites are equal)
% \begin{equation*}
%   \begin{tikzcd}
%   G_0 \arrow[r,"i_{0}"] &
%   G_1 \arrow[r, "i_k"] \arrow[l, "s_0"] \arrow[l, "t_0"] \arrow[l, "c_0"] &
%   G_2 \arrow[l, "t_k"] \arrow[l, "c_k"] &
% \end{tikzcd}
% \end{equation*}

%   We call each member of $G_{k}$ a $k$\textbf{-cell}.
% \end{definition}
 \begin{definition} A \textbf{Welkin Information Graph} $G = \{G_{n}\}$ consists of sets $G_{0}, G_{1}, \cdots, G_{n}$ called $\textbf{layers}$
   such that for each $1 \leq k \leq n,$ $G_{k+1}$ is a reflexive ternary relation on $G_{k}.$ In other words,
   \begin{itemize}
  \item $G_{k+1} \subseteq G_{k}^{3},$ and
     \item for each $I \in G_{k},$ $(I, I, I) \in G_{k+1}.$
    We call each member of $G_{k}$ a $k$\textbf{-unit}. We denote $0-$units by $A \xrightarrow{e} B,$ and for all other units, we use the notation $A \xRightarrow{e} B.$ In particular, if $A \in G_{k}, a \in G_{k+2},$ $A \xRightarrow{a} A$ means $(A, A, A) \xRightarrow{a} (A, A, A).$

   \end{itemize}
   Notice that the second condition implies the map $i_{k}: G_{k} \hookrightarrow G_{k+1}$ given by $i(A) = (A, A, A)$ is well-defined.
   % TODO: develop this paragraph more. This is essential for connections accross layers!
   % Best approach: define i accross ALL the k.
   We may therefore ``mix'' between cells at different layers via recursion.
   \begin{itemize}
     \item \textbf{Basis:} $i(A) = (A, A, A)$
    \item \textbf{Recursion:} if $I_{1}, I_{2}, I_{3}$ are cells, then $\cdots$
   \end{itemize}

    \end{definition}

 We abuse notation to , defined via recursion. and refer to $A$ synonymously with $(A, A, A).$ We can generalize this equivalence for any cells $I_{1}, I_{2}, I_{3}$ via recursion. More generally, the cell $(I_{1}, I_{2}, I_{3})$ for $A, B \in G_{k_1}, I \in G_{}$
 Formally, this may be done by taking a map $i: G_{i}$


% We will abuse notation and write $\mathcal{G}$ for $G$ and $\mathcal{G}_{k}$ for $G_{k}.$
% Cite: WIGs are a special form of reflexive n-graphs, or n-globular sets. We add the labeling function to
% store a record of labels from a previous Welkin file, and the last property is used to distinguish internal arcs from
% connectors
% The first three equations ensure that two cells $I_{1} = A_{1} \xrightarrow{e_{1}} B, I_{2} = A_{2} \xrightarrow{e_{2}} B_{2}$ are equal precisely when $(A_{1}, e_{1}, B_{1}) = (A_{2}, e_{2}, B_{2})$. In particular, we have $i(A) = A \xrightarrow{A} A,$ so we may associate each element of $G_{k}$ with a triple in $G_{k+1}.$ These equations mean that a WIG is, under cryptomorphism, equivalent to a list of nested ternary relations.
WIGS are generalizations of multi directed graphs in two different ways:
\begin{itemize}
  \item Arcs (or arrows) are defined by three vertices instead of two.
  \item There can be arcs between arcs. In our definition above, these are separated by each $G_{k}.$
\end{itemize}
% TODO: decide where to put category theory references. May be helpful for category theorists looking at this
% standard!
Graphs and connections, as defined in Base Welkin, are special cases of these arcs.
\begin{definition}
  \item A \textbf{graph} for unit $A \in G_{k}$ is the set of units $G(A) = \{ A \xRightarrow{a} A \}.$
  \item A \textbf{connection} is any cell of the form $(A, I, B) \in G_{k+2},$ where $A, B \in G_{k}, I \in G_{k+1}.$
\end{definition}
%Moreover, notice that our definition does not require every vertex to have an alias, as opposed to a colored graph (in which all vertices are colored).
% TODO: is the claim below true? What we want to say is that some structure may not always be apparent in a Welkin file (particularly if a high level grammar is used). To find more structure, more often than not, a new welkin annotation file is needed.
% There are several examples demonstrating that, under a suitable transformation, a normalized WIG may contain new structures not found in a Welkin file. See Example ??.

We provide the following definition that are nearly identical with graph morphisms. We will return to this definition later in Section ?.?
\begin{definition} Let $\mathcal{G}, \mathcal{H}$ be WIGs. A \textbf{morphism} $f: \mathcal{G} \to \mathcal{H}$ is a map such that for each $0 \leq k \leq n,$ $(A, I, B) \in G_{k}$ implies $(f(A), f(I), f(B)) \in f(G_{k}).$ An \textbf{isomorphism} is an invertible morphism, and an \textbf{automorphism} is an isomorphism $\alpha: \mathcal{G} \to \mathcal{G}.$
\end{definition}
% TODO: use the mixed cell argument to show that this must be true accross ALL connections. Again, pretty
% important for examining isomorphisms that cross layer boundaries.
\begin{lemma}
Morphisms preserve ``mixed'' cells.
\end{lemma}

\begin{lemma}
  The conversion from ASTs to Welkin Information Graphs is valid and is given by $\mu: \mathcal{T} \to \mathcal{W}, \mu(\mathcal{A}) = ...$
\end{lemma}

The final output of parsing is a normalized WIG. We define Welkin Canonical Form in the following fashion.
\begin{definition}
A WIG is in \textbf{Welkin Canonical Form (WCF)} if ...
\end{definition}
Based on this form, we have chosen a unique way to represent Welkin files. In particular, there is a representation under WIG (generalized) homotopies. We prove that there is a polynomial (or exponential?) algorithm to convert any WIG into WNF.

\section{General Application Behavior}

Note that all apparent structures may be adjusted under cryptomorphism.
\subsubsection*{Directives}
Each directive relies on the following components.
\begin{itemize}
  \item Parser: takes in a Welkin file and generates an AST,
  \item Validator: ensures that the AST is valid, raising an error that directly points to a violation,
  \item From here, an AST may be processed by three different means:
		\begin{itemize}
		  \item Recorder: takes the AST, converts it into a WIG in WCF, serializes the data,
		  \item Attributor: %TODO: change name!
		  \item Binder:
		\end{itemize}
\end{itemize}
\begin{center}
  \begin{tabular}{| c | c | c |}
	Directive & Definition & Example \\
	\hline
	\texttt{import} & \makecell{Concatenates input // with current file} & Example

  \end{tabular}
\end{center}

\subsection{Customization}
All Welkin files are infinitely customizable via the welkin config file, which is written in Attribute Welkin. Any attribute can be used, and other Welkin files can be imported. A base config file is required to customize a Welkin grammar. From there, configs can be arbitrarily nested to create and connect any desired (context-free) grammar, validator, recroder, and displayer.
% TODO: figure out best way to apply these directives to an entire folder or set of files
% TODO: replace itemzie with listing
% TODO: decide how to work with a folder (or folders) of config files
% \begin{itemize}
% 	\item Encoding
% 				\begin{itemize}
% 					% TODO: list major ascii versions/varieties. Need an official reference for this!
% 					\item Options: ascii, utf-8, utf-16, other
% 					\item In the case of other: we need to specify how to define an encoding. (We need a light-weight API for implementations)
% 				\end{itemize}
% 	\item Grammar
% 				\begin{itemize}
% 					\item Strength: bounded (only finitely nested graphs with a given nesting limit, no recursion), no-self (arbitrary nesting limit, but no recursion), full (recursion allowed)
% 					\item Customized: use a builtin template or custom welkin file. These can be used to change any part of the grammar, including adding keywords, the symbols used, adding new symbols, etc. Essentially, this will be a way to built new grammars from the original specification; we will need a separate parser for this (i.e., a parser of BNF/Welkin accepted notation).
% 				\end{itemize}

% 	\item (Optional) Language
% 				\begin{itemize}
% 					\item Defaults to English. Can be written in the writer's desired language (as long as it has been configured in Encoding above)
% 				\end{itemize}
% \end{itemize}

% In Welkin, we informally write the BNF above as follows:
% % TODO: explain unit notation (as it maybe clearer than the recursion below). In other words, mark arbitrary variables with the keyword unit
% % TODO: decide whether to introduce another arrow symbol for custom grammars.
% % While we have imposed few to no restrictions on custom grammars (besides being LALR), it may be the case
% % that multiple people want to use => for their own purpose. Is there a convenient way we can do this?
% \begin{quote}{\ttfamily \raggedright \noindent
% 	term -> \{ graph connection ident string\}\\
% 	graph -> \{\{ident \{\}\}->`\{'--term--`\}'\}\\
% 	connection -> \{term--connector--term\}\\
% 	connector -> \{edge arrow\}\\
% 	edge -> `--'\\
% 	arrow -> `->'\\
% 	ident -> CHAR*\\
% 	string -> ``'' CHAR* ``'' | `\`' CHAR* `\''
% }\end{quote}

\section{Core Algorithms}

\subsection{Graph Encoding}



\label{ch:spec}
