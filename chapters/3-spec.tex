% SPDX-FileCopyrightText: 2023 Oscar Bender-Stone <oscarbenderstone@gmail.com>
% SPDX-License-Identifier: MIT
% 4-spec.tex - Specifices the Welkin language and provides a theoretical framework
% for general implementations

% TODO: create a version for welkin-standard.tex that directly includes the copyright notice
% Henceforth, compliant Welkin implementations will be collectively referred to as ``Welkin.'' A formal definition of

This document describes the Welkin information language, a programming language aimed and preserving, analyzing, and extending information.


This edition of the standard, in English, is the basis for all other translations. Only the grammars will be given in an English (specifically ASCII) and should be copied identically. However, these grammars can be built upon via Section ?.?, and any other terms in this document may be translated or changed as necessary.

Throughout this document, every instance of ``Welkin grammar'' means ``standard Welkin grammar.'' Every instance of ``Welkin interpreter'' means ``conformant Welkin interpreter.'' For a definition of conformance, refer to Section ?.?

\section{Preliminaries}

% Helpful macros for terms for character encoding in math mode
\newcommand*{\chars}{\mathrm{CHAR}}
\newcommand*{\numbers}{\mathrm{NUMBERS}}
\newcommand*{\whitespaces}{\mathrm{WHITE\_SPACES}}
\newcommand*{\reserved}{\mathrm{RESERVED}}
\newcommand*{\strings}{\mathrm{STRING}}
\newcommand*{\term}{\mathrm{term}}
\newcommand*{\terms}{\mathrm{terms}}
\newcommand*{\delimiters}{\mathrm{DELIMITERS}}
\newcommand*{\escapes}{\mathrm{STRING\_ESCAPES}}
\newcommand*{\encoding}{\mathcal{E}}
\newcommand*{\decoding}{\mathcal{D}}
\newcommand*{\can}{\textrm{Can}}


\newcommand*{\scope}{\textrm{scope}}

\SetBNFConfig{
  relation = {::=|=>},
  relation-sym-map = {
    {::=} = {=},
    {=>} = {->},
    {<~} = {},
  }
}
\subsection{Mathematical Background}
This standard requires a cursory background in discrete mathematics, parsing, and Backus-Naur Form (BNF). A reading of [] and [] suffices to understand this document. We clarify on our mathematical notation below.

Let $A, B, C$ be sets. We denote by $A^{}*$ the set of finite sequences of $A$ (or \texttt{A*} in grammars), including the empty sequence $\varepsilon := \emptyset,$ and we call each $w \in A*$ a \textbf{word.}
% \footnote{Traditionally, the set of finite sequences over a set $A$ is denoted by $A^{*}.$ However, to ensure every BNF in this document
%   can be written in pure ASCII, we append $*$ without a superscript on $\chars$ and its subsets.}

Let $f: A \to B,$ $g: B \to C$ be functions. We denote the composite of $f$ and $g$ by $g \circ f,$ and by $f*: A \to B*$ the extension of $f$ to finite sequences of $A$ componentwise to finite sequences in $B.$


\subsection{Character Encodings}
% TODO: generalize to byte encodings and numbers.
We define text, character encodings, and character decodings as abstract notions. The discussion here may be carried out in terms of bytes and specific data formats, but these concepts are beyond the scope of this standard.

Let Char be a finite set. An \textbf{encoding} is an injective mapping $\encoding : \mathbb{N} \to \textrm{Char}.$ The associated \textbf{decoding} is the left-inverse $\decoding: \mathrm{Char} \to \mathbb{N}$ of $\encoding.$ We denote $\chars = \decoding(\textrm{Char}).$

Character encodings may be given as finite tables, matching natural numbers with characters. Several major encodings are defined in the following sources.
% TODO: put these references in bibtex
% US-ASCII (see references therein): https://www.iana.org/assignments/character-sets/character-sets.xhtml
% UTF-8, UTF-16: https://www.unicode.org/versions/Unicode15.0.0/UnicodeStandafinite rd-15.0.pdf
\begin{itemize}
	\item US-ASCII []. We will refer to this simply as ASCII\footnote{American Standard Code for Information Exchange}, but there are subtle variations accross specific nationalities and applications (see []).
	\item UTF-8, UTF-16 []. The Unicode Standard defines encodings across numerous human languages and unique characters.  % TODO write notes about both
\end{itemize}

% We render special characters, frequently used in our BNF, as glyphs. See Table ?.? for more details.

Although ASCII is a subset of UTF-8, this standard will prioritize ASCII as much as possible. Every BNF grammar (see Section ?.?) for this standard will be written in ASCII as a unifying encoding, but users may create grammars using UTF-8, UTF-16, or their own encodings (see Section ?.?).
% TODO: put this into table format. We need an easy way to reference any of these sets and notes about them
% Defining each subimage linearly is not working that well.


% TODO: decide if BNF encoding is a good name. Maybe something to do with terminals?
% TODO: decide if string escapes is parametric or must be consistent
% TODO: allow numbers to be delimtiers (in case users want that)
\begin{definition}
  A \textbf{BNF encoding} under Char is an encoding $\encoding: \mathbb{N} \to \textrm{Char}$ along with four subsets $\chars*,$
  \begin{itemize}
  \item $\whitespaces$
  \item $\numbers$
  \item $\delimiters$
  \item $\escapes$
  \end{itemize}
  such that $\whitespaces$ is pair-wise disjoint with every other subset.

Moreover, let $\strings$ be the set of strings over $\delimiters,$ where a string is a word $d_{1}wd_{2}$ such that $w \in (\chars \setminus \delimiters \cup \escapes(d_{1}, d_{2}))*.$ Notice that $\delimiters, \escapes$ can be defined in terms of $\strings.$
\end{definition}
In our BNF encoding, we assume all sets above are non-empty. The first is an optional addition, adding support for defining machine representable numbers; the second distingushes words from one another; and the last two are used for arbitrary strings. Any of these sets, however, can made empty with a different grammar (see Section ?.?).

% \begin{definition} A \textbf{BNF encoding under} Char is an encoding $\mathcal{E}: \mathcal{N} \to \textrm{Char}$ along with three disjoint subsets.



% \end{definition}

% Let $\escapes \subsetq \Char{*} \setminus W.$ This is optional and enables a grammar to include an existing literal in
% TODO: decide if this should be a separate definition
Every Welkin grammar, written in a BNF metasyntax, uses the ASCII encoding with
\begin{itemize}
  \item $\numbers = \emptyset$,
  \item $\whitespaces = $ = ASCII whitespace characters,
  \item STRING = all ASCII characters enclosed by single or double quotes. We escape single (double) quotes via \' (\textbackslash'').
\end{itemize}

% We list several distinguished subsets secondary notions in Table ?.? All of these sets, except $\strings(d)$ and $D_{\strings},$ are arbitrary.
% % TODO: Remove member notation? It seems like we don really need it
% \begin{center}
%   \bgroup
%   \def\arraystretch{2.0}
% \begin{tabular}{| c | c | c |}
%   \hline
%   \textbf{Set} & \textbf{Definition} & \textbf{Member Notation} \\
%   \hline
%   NUMBERS & Subset of $\chars*$ & $r$ \\
%   \hline
%   WHITE\_SPACES & Subset of $\chars*$ & $ws$ \\
%   \hline
%   DELIMITERS & Subset of $(\chars*)^{2}$ & $d = (d_{1}, d_{2})$ \\
%   \hline
%   STRING($d$) & \makecell{$s = d_{1}wd_{2},$ $d_{1}, d_{2} \not \subseteq_{ws} w.$ \\ $w$ is the \textbf{contents of} $s$ } & \makecell{$s_{d},$ with \\ contents $\hat{s}_{d}$} \\
%   \hline
%   STRING & Subset of $\bigcup \strings(d)$ & \makecell{$s,$ with \\ contents $\hat{s}$} \\
%   \hline
%   $D_{\strings}$ & \makecell{Set of delimiters \\ appearing in $\strings$} & \makecell{$d_{\strings}$} \\
%   \hline
%   ESCAPE$(W)$ & Subset of $\chars*\setminus W$ & $escape_{W}$ \\
%   \hline
%   ESCAPE & Subset of $\bigcup \escapes(d)$ & $escape$ \\
%   \hline
% \end{tabular}
% \egroup
% \end{center}

% Strings may include their delimiters by using $\escapes(\{d_{1}, d_{2}\})$ as a prefix or suffix.

% We implicitly assume that does not conflict with literals defined in a grammar. In terms of the recommended LALR parser, this means that literals are matched first, not identifiers. However, these characters may be used by creating a custom grammar (see Section ?).

A \textbf{text} is a subset of $\chars*.$ We will not consider streaming issues, i.e, we will assume every Welkin file is present at one time.
% TODO: describe issues with files! How to work with this?

\subsection{BNF Variant}
Our variant of BNF uses the notation shown in Table ?.? and in Definition ?.?. Our notation, as well as every standard Welkin grammar, is available in ASCII.

Each BNF has an associated subset $\reserved \subseteq \chars*$ for any literals that appear in the grammar. We will explicty state these for Welkin variants in the next section.

% TODO: fix spacing issues with all rows. BNF is not fitting in there well!
\begin{center}
  \begin{tabular}{ | c | p{2cm} | p{6cm} | }
  \hline
  \textbf{Concept} & \textbf{Notation} & \textbf{Example} \\
  \hline
  Rule Assignment & $=$ & \begin{bnf} term ::= atom\end{bnf}\\
  \hline
  \makecell{Empty Word \\ (In ASCII)} & empty & \begin{bnf} term ::= empty\end{bnf}\\
  \hline
  Alternation & $|$ & \begin{bnf} boolean ::= true | false \end{bnf}\\
  \hline
  \makecell{Concatenation \\ (No white spaces \\ inbetween rules)} & \makecell{Separate with \\  a period (.)}&  \begin{bnf} function ::= name.``(''.number.``)''\end{bnf} \\
  \hline
  \makecell{Concatenation \\ (Zero or more \\ white spaces allowed)} & \makecell{Separate with \\ white space} & \begin{bnf} data ::= date name\end{bnf} \\
  \hline
  Groupings & Parantheses () & \begin{bnf} boolean ::= (true // false)\end{bnf} \\
  \hline
  Literals & ``word'' & \begin{bnf} boolean ::= ``true'' // ``false'' \end{bnf} \\
  \hline
  Choice Names & terms $\to$ rule & \makecell{\begin{bnf} boolean ::= ``true'' $\to$ true || ``false'' $\to$ false \end{bnf}, \\ equivalent to \\ \begin{bnf}  boolean ::= true // false ;; true ::= ``true'' ;; false ::= ``false'' \end{bnf}} \\
  \hline
  \makecell{Rule Substitution \\ (Definition ?.?)} & rule1[rule2 $\to$ rule3] & \makecell{\begin{bnf} rule1 ::= rule2 \end{bnf}, \\ equivalent to \\ s } \\
    \hline
  \end{tabular}
  \end{center}

We introduce one new notion that is definable with BNFs.
\begin{definition} (Rule Substitution) Let $rule_{1}, rule_{2}$ be rules with $rule_{2}$ appearing on the right hand side of $rule_{1}.$ Suppose $rule_{3}$ appears on the lefthand side of $rule_{2}.$ Then $rule_{1}[rule_{2}\to rule_{3}]$ is $rule_{1}$ with every instance of $rule_{2}$ replaced by $rule_{1}.$

% TODO: clean up this definition!
Some particular cases:
\begin{itemize}
\item $term[empty]$ means no rule should be applied.
\end{itemize}

\end{definition}

An conformant parser for all three grammars should include the ability to compose and override rules. This ensures that any updates to grammars, if necessary, are isolated. See more details in Section ?.?.
% TODO: convert this into a table for easy access
% \begin{itemize}
%   \item \texttt{term ::= $S \subseteq \chars^{*}$} means \texttt{term $\in S$},
% or most one instances and is shorthand for
% 	\begin{center}
% 		\texttt{terms ::= term terms | term},
% 	\end{center}
%
\section{The Welkin Language}

There are three fundamental variants of Welkin that define the foundation for the language:
\begin{itemize}
	\item Base Welkin, mirroring the key properties of the core data structure.
	\item Attribute Welkin, extending Base Welkin with attributes. Attributes are a limited type of directive that can customize how the interpreter accepts or presents data.
	\item Binder Welkin, enabling arbitrary evaluation of Welkin files and access to the user's operating system. This is equivalent to Attribute Welkin with three new directives: \texttt{@eval}, \texttt{@exec}, and \texttt{@bind}. \end{itemize}
Each of these variants can be parsed with LALR parsers and fundamentally have the same semantics. However, in Binder Welkin, \texttt{@eval} makes the interpreter Turing complete (see Section ?.?), and using \texttt{@exec} can run external programs that impact the user's system. For this reason, Binder Welkin is a separate, optional component, as detailed in the Section ?.?
%\renewcommand{\syntleft}{\normalfont\bfseries}
%\renewcommand{\syntright}{}

% TODO: There should be some consistent procedure to ensure that the BNF here
% is the same as those found in any implementation
%\renewcommand{\bnfexpr}{\textbf}
\subsubsection*{Syntax}
Define each $\reserved$ set as follows. % TODO: figure out better way to display these! Hard to read delimiters!
\begin{itemize}
\item $\reserved_{\textrm{base}} = \{\texttt{\{, \}, ., -, ->, <} \},$
\item $\reserved_{\textrm{attribute}} = \{\texttt{\{, \}, (, ), [, ], ., , , -, ->, <-, @\}},$
\item $\reserved_{\textrm{binder}} = \reserved_{\textrm{attribute}}.$
\end{itemize}
Each grammar is provided in Table 3.?.
% TODO; figure out rule for when NUMBERS is empty
% TODO: make different RESERVED key words for Base and Attribute Welkin. Binder Welkin is fairly straightforward
% (We actually only need to look at prefixes; any attribute names WILL be parsed first. Welkin will assume
% the user wanted the built-in directives. A different name for those should be used)
% TODO: It may be better to type up Welkin in regular font; it looks readable and could be done well in math mode.

% \SetBNFConfig{

%   relation-sym-map = {
%     {::=} = {\ensuremath{=}},
%   }
%   }
%     TODO: Remove Notes column
% TODO: add -> back into the grammar; using -> directly conflicts with simplebnf
\begin{table}[hbt!]
  \centering
    \begin{tabular}{| p{1.5cm} | p{9.5cm} |}%{1\textwidth}{| l | X |}
    \hline
    Variant & Grammar \\\hline % & Notes \\
      \makecell{Base \\ Welkin} &
  \begin{bnf}
  terms ::= term* ;;
  term ::= (graph // connections // member // unit) ;;
  graph ::= unit? ``\{'' terms ``\}'' ;;
  connections ::= term (connector term)+ ;;
	connector ::=
   | ``-'' term ``-'' $\to$ edge
   | ``-'' term ``>'' $\to$ left\_arrow
	 | ``<-'' term `-' $\to$ right\_arrow ;;
  member ::= unit? (``.''.(ident // string)? // ``\#''.num )+ ;;
	unit ::= ident // string // num ;;
  ident ::= CHAR* ;;
	string ::= STRING ;;
	num ::= NUMBER
\end{bnf} \\ %& If $\numbers = \emptyset,$ any instance of \texttt{num} should be removed from the parser. \\
   \hline
      Attribute Welkin &
  % TODO: decide how to make import and override statements a part of bnf
  \makecell{\%import grammars/base.txt \\ \%override term}
  \begin{bnf}
  term ::= ``@''.(directive // graph[directive]) | construct // graph // connection | member // unit ;;
  directive ::= attributes ;;
  attributes ::= ``import''.tuple $\to$ import
  | ``self''.(member?) $\to$ self
  | ``alias''.graph[empty] $\to$ alias
  | ``resource''.graph[unit] $\to$ resources
  | ``metadata''.graph[unit] $\to$ metadata
  | ``input''.graph $\to$ input
  | ``parse''.(graph // unit) $\to$ parse
  | ``validate''.tuple $\to$ validate
  | ``record''.term $\to$ record
  | ``output''.graph $\to$ output
  | graph[unit] $\to$ custom ;;
  construct ::= operation // tuple // list // series // all\_terms ;;
  operation ::= term.tuple // term unit term ;;
  tuple ::= ``('' series ``)'' ;;
  list ::= ``['' series ``]'' ;;
  % series ::= term ``,'' (term ``,'')* term ``,''? ;;
  % all_terms ::= ``*''
 \end{bnf} \\
                      %& This is limited to the CLI and GUI (TBD). \\
   \hline
   Binder Welkin &
\makecell{\%import grammars/attribute.txt \\ \%override directives}
    \begin{bnf}
     directives ::= attributes // binders ;;
     binders ::= ``eval''.tuple[unit] $\to$ eval
     | ``exec''.tuple[string] $\to$ exec
     | ``bind''.graph[empty] $\to$ bind
   \end{bnf} \\
    \hline
    \end{tabular}
  \end{table}


% Throughout this document, Welkin documents are formatted with the following convention: the ASCII sequence \texttt{->} is rendered as $\to$ (A graphical user interface may support this rendering via glyphs). % TODO: put special renderings in a table
  % TODO: figure out suitable grammar composition notation

% TODO: recognize, in cflt, that the above welkin file is in fact a context free grammar! The more important part, which we need to still define, is the semantics, which will have its full strength with the full grammar. (Maybe we should change that option to be semantics instead?)

\subsubsection*{Semantics}
We break down our semantics first by terms. Directives are handled separately in the next section.
% TODO: make this more efficient. (Probably best to follow the structure from a logic textbook)
\begin{definition}
Equality of terms.
\begin{itemize}
    % TODO: decide if ''A`` is the same as A
  \item \textbf{Basis.} Two units are equal if they are the same kind and obey one of the following.
	\begin{itemize}
	  \item \texttt{ident} terms are equal if their corresponding characters are equal,
      \item \texttt{string} terms are equal if their corresponding contents are equal. Thus, if $", '$ are delimiters, \texttt{``A''} coincides with \texttt{'A'},
	  \item \texttt{num} terms are equal if they represent the same value. Thus, \texttt{1} coincides with \texttt{10E}.
	\end{itemize}
  \item \textbf{Recursion.}
        \begin{itemize}
        \item Two members are the same if they contain the same list of units. % TODO: include the case of relative imports
        \item Two connectors are equal if they are equal as terms. %TODO: rework to make this clearer
 		  \item Two connections are equal if they connect the same terms and have equal connectors.
		  \item Two graphs are equal if they contain the same terms.
	\end{itemize}
\end{itemize}
\end{definition}
% This definition should be unnecessary; this should be clear from the BNF.
% \begin{definition} (Membership) Let $t$ be a term and $G$ a graph. We say $t$ is a \textbf{member} of $G$ if $t$ appears as the contents of $G.$\end{definition}
% \end{definition}
A \textbf{scope} is recursively defined and intutively is a level of terms.
\begin{definition} (Scope)
 Let $t$ be a term.
  \begin{itemize}
	\item If $t$ is not contained in a graph, then $\scope(\texttt{term}) = 0,$
	\item If $G' \in G$ are both graphs and $\scope(G') = n,$ then for all $t \in G',$ $\scope(t) = \scope(G) + 1.$
\end{itemize}
\end{definition}
A \textbf{valid} base Welkin file consists satisfies a unique naming rule: in every scope, there are no name collisons. In particular, every graph must \textbf{only be defined once.} Note that, by the way equality was defined between two numbers,
  there can only be one representation of a given number in a scope. For example, using \texttt{1} and \texttt{10E-1} in the same scope would produce a name collison.
\\ We first form an Abstract Syntax Tree (AST), from which we form the final stored data in a \textbf{Welkin Information Graph.}
\begin{definition}
  Base Welkin is parsed into the following AST $\mathcal{A}.$
  \begin{itemize}
	\item Every term is a new subtree with its contents as children.
    \item Every graph is an ordered pair of its name and list of children.
    % TODO: how to deal with empty connectors? Big issue for parsing and storing in a WIG!
    \item Every connection is an ordered pair:
		  \begin{itemize}
			\item Left arrows $u \xrightarrow{e} v$ correspond to a triple $(u, e, v);$
			\item Right arrows $u \xrightarrow{e} v$ correspond to the triple $(v, e, u);$
			\item Edges correspond to both a left and right arrow.
		  \end{itemize}
	\item Every unit is encoded via $\encoding^{*}.$ Numbers are further transformed into a machine representable form, which is dependent on the implementation.
  \end{itemize}
 \end{definition}
% TODO: talk about encoding of numbers in the structure itself. This probably a separate encoding from the one used to write the welkin file

\begin{definition} A \textbf{Welkin Information Graph} $G = (V, C, L, l)$ consists of
  \begin{itemize}
    \item set $V$ of \textbf{vertices,} with $\varepsilon \not \in V,$
    \item a set $C \subseteq V \times (V \cup \{\epsilon\}) \times V$ \textbf{connections,}
    \item a set $L$ of \textbf{labels,} and
    \item an injective function $l: L \to V,$ called the \textbf{labeling function},
  \end{itemize}
  such that $C$ is reflexive: for all $A \in V,$ $(A, A, A) \in C.$
  % TODO: make this nicer
  The last condition implies that the function $i: V \to C,$ given by $i(A) = (A, A, A),$ is well-defined. From this map, we abuse notation and write $A$ and $(A, A, A)$ synonymously. (The use of this notation is clear from context). \end{definition}

% TODO: talk about whether edges can collapse into loops. This is not possible in an isomorphism, but it is worth mentioning
\begin{definition}
  Let $G = (V_{G}, C_{G}, L_{G}, l_{G}), H = (V_{H}, C_{H}, L_{H}, l_{H})$ be WIGS. A \textbf{morphism} $f: G \to H$ is a pair of functions $f_{V}: V_{G} \to V_{H}, f_{C}: C_{G} \to C_{H}$ with $f_{C}(A, e, B) = (f_{V}(A), f_{V}(e), f_{V}(B))$ for $A, e, B \in V_{G},$ . Equivalently, $(A, e, B) \in C_{G}$ implies $(f_{V}(A), f_{V}(e), f_{V}(B)) \in C_{H}.$
  % TODO: rephrase these
  \begin{itemize}
    \item $f$ \textit{preserves connections:} $(A, e, B) \in C_{G}$ implies $(f(A), f(e), f(B)) \in C_{H},$
    \item $f$ \textit{is 3-injective} $f(A) = f(e) = f(B)$ and $(f(A), f(e),f(B)) \in C_{H}$ implies $A = e = B$ and, subsequently, $(A, e, B) \in C_{k}.$
  \end{itemize}


\end{definition}

% send edges to edges:
% send loops to loops: (A, A, A)
% Feels VERY much like a monoid! (BUT without composition)


\begin{definition}
  Let $G$ be a WIG. The \textbf{Welkin Canonical Form (WCF)} of $G$ is the WIG $\can(G) = (V', E', C', L, l'),$
  where
  \begin{itemize}
    \item $\can(V) = \{0 \leq k \leq |G|\},$
    \item $(\can(A), \can(B)) \in \can(E)$ if $(A, B) \in E$
    \item $(\can(A), \can(E), \can(B)) \in \can(C)$ if $(A, E, B) \in C.$
    \item (Condition on labeling)
  \end{itemize}


\end{definition}

The next lemma defines the basis for the recorder. Every WIG must be put into a universal form that can be labeled in completely different ways. The underlying structure of the WIG is always preserved, no matter what labels are added.
\begin{lemma} For any WIG $G,$ $G \cong \can(G).$
\end{lemma}

In fact, the structure of a WIG can only be appended. Any new additions to the graph do not remove existing structure.


%  \begin{definition} A \textbf{Welkin Information Graph} (WIG) $G = (\{G_{k}\}, \{c_{k}, u_{k}\})$ consists of
%    \begin{itemize}
%      \item tuples $G_{k} = (V_{k}, E_{k}, F_{k})$ called $\textbf{layers},$ where
%            \begin{itemize}
%              \item $V_{k}$ is a set of \textbf{vertices} or \textbf{units,}
%              \item $E_{k} \subseteq V_{k}^{2}$ is a set of \textbf{edges,}
%              \item $F_{k} \subseteq V_{k} \times E_{k} \times V_{k},$ is a set of \textbf{faces} or \textbf{connections;}
%            \end{itemize}
%      \item functions $c_{k}: V_{k} \to \mathcal{P}(V_{k+1}),$ called the $k$-th \textbf{contents map,}
%      \item injective functions $u_{k}: V_{k+1} \to V_{k},$ called the $k$-th \textbf{unit map,}
%    \end{itemize}
%    such that for $k \leq n,$
%     \begin{itemize}
%     \item $E_{k}, F_{k}$ are reflexive: for all $I \in V_{k},$
%             $(I, I) \in E_{k}$ and $(I, (I, I), I) \in F_{k}.$
%     \end{itemize}
%     \end{definition}

%     % Extremely important discussion: describe composities of c and u to ensure that we can always
%     % have connections between ANY vertices, no matter where they are. This means explaining both:
%     % the semantics of A.b - e -> B.b
%     % the semantics of .a - e -> .b, and
%     % TODO: fix up this notation. Important for extensions!
%     Notice that the third condition implies the $k$-th \textbf{identity assignment} $i_{k, 1}: V_{k} \hookrightarrow E_{k+1}, i_{k, 2}: E_{k} \to C_{k+1}$ given by $i_{k, 1}(A) = (A, A), i_{k}(A, B) = (A, (A, B), B)$ are well-defined. Through these maps, we will abuse notation and write $A \in E_{k}, E \in C_{k}$ whenever $A \in E_{k}, E \in C_{k}.$ We write $A \in G_{k}$ if $A$ is a kth vertex, edge, or face, $A \in G$ if $A \in G_{k}$ for some $k.$

% To encompass a wide range of connections, we extend these map, as well as the content and unit maps, to form edges between all faces as follows.
%     % TODO: maybe find more concise ways to state these extensions?
%     % TODO: choose this or recursive definition? Note: this is essentially a transitive closure, treating c, u
%     % as generalized membership relations. (c is definitely more suited for this; u is more of a mechanism for
%     % encoding .a - e -> .b with relative members)
% %  TODO: Explain relevance of this construction in explicitly in Lemma 2.4!
% \begin{definition} (Extensions). Let $A \in G_{k_{1}}, B \in G_{k_{2}}$ with $k_{2} > k_{1}.$
%     \begin{itemize}
%       \item $B \in c(A)$ if for some $k,$ $B \in c^{(m)}_{k}(A),$
%       \item $u(B) = A$ if for some $k,$ $u^{(m)}_{k}(B).$
%     \end{itemize}
% \end{definition}


% \begin{definition} (Generalized Connections). Let $A, B, C \in G_{k}.$ Then $(A, B) \in E_{k}$ if $\cdots$
% \end{definition}

% Graphs and connections, as defined in Base Welkin, are special cases of these arcs. In fact, the contents of $A,$ along with restrictions to $c,$ forms a WIG.
% % TODO: restrict following contents functions to only A and its units' contents
% \begin{lemma}

% For any $A \in V_{k},$ $\hat{A} := (c(V_{k}), \{c'_{k}\})$ is a WIG.
% \end{lemma}
% \begin{lemma}
% WIGs are closed under unions and complements, as well as intersections by De Morgan's Laws. % TODO: find all relevant properties
% \end{lemma}
% Both lemmas above ensure that arbitraily many units can be defined and gradually appended to a WIG.


% % \end{itemize}
% % TODO; fix these for both E and F
%    % TODO: develop this paragraph more. This is essential for connections accross layers!
%    % Best approach: define i accross ALL the k.
%    % We may therefore ``mix'' between cells at different layers via recursion.
%    % \begin{itemize}
%    %   \item \textbf{Basis:} $i(A) = (A, A, A)$
%    %  \item \textbf{Recursion:} if $I_{1}, I_{2}, I_{3}$ are cells, then $\cdots$
%    % \end{itemize}

% % Cite: WIGs are a special form of reflexive n-hypergraphs, or generalized n-globular sets. We add the labeling function to
% % store a record of labels from a previous Welkin file, and the last property is used to distinguish internal arcs from
% % connectors
% WIGS are generalizations of directed multigraphs in two different ways:
% \begin{itemize}
%   \item Faces are a generalized edge defined by three vertices instead of two.
%   \item There can be edges between edges. In our definition above, these are separated by each $G_{k}.$
% \end{itemize}
% % TODO: decide where to put category theory references. May be helpful for category theorists looking at this
% % standard!
% %Moreover, notice that our definition does not require every vertex to have an alias, as opposed to a colored graph (in which all vertices are colored).
% % TODO: is the claim below true? What we want to say is that some structure may not always be apparent in a Welkin file (particularly if a high level grammar is used). To find more structure, more often than not, a new welkin annotation file is needed.
% % There are several examples demonstrating that, under a suitable transformation, a normalized WIG may contain new structures not found in a Welkin file. See Example ??.

% We provide the following definition that are nearly identical with graph morphisms. We will return to this definition later in Section ?.?
% \begin{definition} Let $G, H$ be WIGs. A \textbf{morphism} $f: G \to H$ is a map such that for each $0 \leq k \leq n$ and all $A, B \in V_{k}, e \in E_{k},$
%   \begin{itemize}
%     \item Edges are preserved: $(A, B) \in E_{k}$ implies $(f(A), f(B)) \in E'_{k}$
%     \item Faces are preserved: $(A, e, B) \in F_{k}$ implies $(f(A), f(B)) \in F'_{k}.$
%   \end{itemize}
%   % TODO: find a better way to state this that is explicit. Little to no graph theory knowledge should be neeed
%   % (this document is meant to be widely accessible)
%   An \textbf{isomorphism} is a morphism with an inverse, meaning it is a bijection and all implications above are replaced with biconditions (if and only if). An \textbf{automorphism} is an isomorphism $\alpha: \mathcal{G} \to \mathcal{G}.$
% \end{definition}
% % TODO: use the mixed cell argument to show that this must be true accross ALL connections. Again, pretty
% % important for examining isomorphisms that cross layer boundaries.
% \begin{lemma}
% Morphisms preserve ``mixed'' cells.
% \end{lemma}

% % TODO: in the conversion, note that A - A - B -> B, equivalent to A --> B, is converted to A - { A - B } -> B. So both of them are equivalent on Welkin. Every other connection, however, will be parsed with full brackets, i.e.,
% % A - {{ A --> B }} -> B will be parsed as it is.
% \begin{lemma}
%   The conversion from ASTs to Welkin Information Graphs is valid and is given by $\mu: \mathcal{T} \to \mathcal{W}, \mu(\mathcal{A}) = ...$
% \end{lemma}

% The final output of parsing is a normalized WIG. We define Welkin Canonical Form in the following fashion.
% \begin{definition}
% A WIG is in \textbf{Welkin Canonical Form (WCF)} if ...
% \end{definition}
% Based on this form, we have chosen a unique way to represent Welkin files. In particular, there is a representation under WIG (generalized) homotopies. We prove that there is a polynomial (or exponential?) algorithm to convert any WIG into WNF.

\section{General Application Behavior}

Note that all apparent structures may be adjusted under cryptomorphism.

\subsubsection{Bootstrap}
The welkin/bootstrap file faciliates the user API to Attribute Welkin. It is currently located at \url{https://github.com/AstralBearStudios/welkin} and is essential for creating a stable Welkin interpreter.

Every Welkin interpreter must implement Base Welkin. To implement Attribute Welkin, the parser must be equipped with a parser for this variant, create a WIG for \texttt{attribute} (with all imported units in bootstrap), and follow the General Application Guidelines for its implementation.

Finally, to support Base Welkin, the interpreter must be written with a programming language that is Turing complete and can execute system resources. The final command, $\texttt{@bind},$ is defined in terms of these notions. % TODO: is it definable in terms of these? Need to check and spell this out!



\subsubsection*{Directives}
Each directive relies on the following components.
\begin{itemize}
  \item Input: processes an input or set of inputs.
  \item Parser: takes in a Welkin file and generates an AST,
  \item Validator: ensures that the AST is valid, raising an error that directly points to a violation,
  \item From here, an AST may be processed by three different means:
		\begin{itemize}
		  \item Recorder: takes the AST, converts it into a WIG in WCF, serializes the data,
		  \item Output: displays some information provided in a Welkin file to the user.
		  \item Evaluator: evaluates, executes, or binds commands into Welkin units.
		\end{itemize}
\end{itemize}

All official implementations may implement
\begin{itemize}
\item Base Welkin alone,
\item Attribute and Base Welkin, or
\item All three variants.
\end{itemize}

In each case, these variants must be implemented according to the welkin/bootstrap file. This file bootstraps the essential information from this standard. (See Section ?.? on a specification of this bootstrap)


% \begin{center}
%   \begin{tabular}{| c | c | c |}
% 	Directive & Definition & Example \\
% 	\hline
%     \texttt{import} & \makecell{Concatenates input \\ with current file} & Example \\
%     \texttt{import} & \makecell{Concatenates input \\ with current file} & Example \\
%     \texttt{self} & \makecell{Gets the \\ current graph} & Example \\
%     \texttt{input} & \makecell{Manage inputs} & Example \\
%     \texttt{parse} & \makecell{Manages parsing data} & Example \\
%     \texttt{validate} & \makecell{Concatenates input \\ with current file} & Example \\
%     \texttt{record} & \makecell{Concatenates input \\ with current file} & Example \\
%     \texttt{output} & \makecell{Manage outputs} & Example \\
%     \texttt{attribute} & \makecell{Concatenates input \\ with current file} & Example \\

%   \end{tabular}
% \end{center}

\subsection{Customization}
All Welkin files are infinitely customizable via the welkin config file, which is written in Attribute Welkin. Any attribute can be used, and other Welkin files can be imported. A base config file is required to customize a Welkin grammar. From there, configs can be arbitrarily nested to create and connect any desired (context-free) grammar, validator, recroder, and displayer.
% TODO: figure out best way to apply these directives to an entire folder or set of files
% TODO: replace itemzie with listing
% TODO: decide how to work with a folder (or folders) of config files
% \begin{itemize}
% 	\item Encoding
% 				\begin{itemize}
% 					% TODO: list major ascii versions/varieties. Need an official reference for this!
% 					\item Options: ascii, utf-8, utf-16, other
% 					\item In the case of other: we need to specify how to define an encoding. (We need a light-weight API for implementations)
% 				\end{itemize}
% 	\item Grammar
% 				\begin{itemize}
% 					\item Strength: bounded (only finitely nested graphs with a given nesting limit, no recursion), no-self (arbitrary nesting limit, but no recursion), full (recursion allowed)
% 					\item Customized: use a builtin template or custom welkin file. These can be used to change any part of the grammar, including adding keywords, the symbols used, adding new symbols, etc. Essentially, this will be a way to built new grammars from the original specification; we will need a separate parser for this (i.e., a parser of BNF/Welkin accepted notation).
% 				\end{itemize}

% 	\item (Optional) Language
% 				\begin{itemize}
% 					\item Defaults to English. Can be written in the writer's desired language (as long as it has been configured in Encoding above)
% 				\end{itemize}
% \end{itemize}

% In Welkin, we informally write the BNF above as follows:
% % TODO: explain unit notation (as it maybe clearer than the recursion below). In other words, mark arbitrary variables with the keyword unit
% % TODO: decide whether to introduce another arrow symbol for custom grammars.
% % While we have imposed few to no restrictions on custom grammars (besides being LALR), it may be the case
% % that multiple people want to use => for their own purpose. Is there a convenient way we can do this?
% \begin{quote}{\ttfamily \raggedright \noindent
% 	term -> \{ graph connection ident string\}\\
% 	graph -> \{\{ident \{\}\}->`\{'--term--`\}'\}\\
% 	connection -> \{term--connector--term\}\\
% 	connector -> \{edge arrow\}\\
% 	edge -> `--'\\
% 	arrow -> `->'\\
% 	ident -> CHAR*\\
% 	string -> ``'' CHAR* ``'' | `\`' CHAR* `\''
% }\end{quote}

\section{Core Algorithms}

\subsection{Graph Encoding}



\label{ch:spec}
