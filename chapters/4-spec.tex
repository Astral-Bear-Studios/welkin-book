% SPDX-FileCopyrightText: 2023 Oscar Bender-Stone <oscarbenderstone@gmail.com>
% SPDX-License-Identifier: CC-BY-4.0
% 4-spec.tex - Specifices the Welkin language and provides a theoretical framework
% for general implementations


\chapter{The Welkin Standard}

\section{Preliminaries}

% Helpful macros for terms for character encoding in math mode
\newcommand*{\chars}{\mathrm{CHAR}}
\newcommand*{\numbers}{\mathrm{NUMBER}}
\newcommand*{\term}{\mathrm{term}}

\subsection{Character Encodings}
% TODO: generalize to byte encodings and numbers.
In a formalist fashion, our BNF variant leaves encodings as an generalized notion. Let Char be an arbitrary, finite set.
An \textbf{encoding} is a mapping $E : \mathbb{N} \to \chars.$
We denote $\chars = E(\chars)$ and CHAR* as the Kleene-closure of CHAR. Moreover there is a distinguished subimage $\numbers \subset chars.$ Character encodings may be given as finite tables. Several major encodings are formally defined in the following sources.
\begin{itemize}
	\item ASCII []
	\item UTF-8 []
	\item UTF-16
\end{itemize}

\subsection{EBNF Variant}
Our variant of EBNF uses the following notation:
\begin{itemize}
	\item Rules are optionally surroudned in angular brackets $<term>;$
	\item $::=$ denotes rule assignment. Any rule ending in $CHAR*$ or $NUMBER*$ means the rule is a member of $CHAR*,$ $NUMBER*,$;
	\item $|$ denotes alternation;
	\item $\term*$ means 0 or more instances and is a shorthand for the rule $terms ::= term terms | term | \varepsilon;$
	\item $\term?$ means at most one instance and is a shorthand for the rule $terms ::= term | \varepsilon;$
	\item Single quotes denote a string in CHAR*. In thesse strings are double or single quotes in CHAR*, the notation [\``] or ['] is used, resectively, to avoid confusion.
\end{itemize}

% \begin{itemize}
% 	\item While there is an ISO standard for EBNF, several authors have noted it has issues. References: \url{https://dwheeler.com/essays/dont-use-iso-14977-ebnf.html}, \url{https://www.grammarware.net/text/2012/bnf-was-here.pdf}. As recommended by David Wheeler in the first reference, we use the BNF Notation defined in the W3 standard (at \url{https://www.w3.org/Notation.html}).
% \end{itemize}
\section{The Welkin Language}

There are two fundamental variants of Welkin:
\begin{itemize}
	\item Base Welkin, a language mirroring the core data structures;
	\item Standard Welkin, which extends Base Welkin with attributes. These attibutes can alter or customize the interpreter's behavior.
\end{itemize}
Both can be parsed with LALR parsers and fundamentally have the same semantics.

% \begin{itemize}
% 	% \item First Define character encodings in general. Helpful reference: \url{https://www.w3.org/International/questions/qa-what-is-encoding}
% 	%       \begin{itemize}
% 	% 	      \item For wide spread use, there should be different character encodings used for \textit{direct comparison} with Welkin files. Ultimately, every Welkin file will be converted into a standard binary (or possibly text) file to store the object
% 	%       \end{itemize}
% 	\item Determine a suitable BNF for Welkin, which can be parsed with LALR (or otherwise a more efficient parser)
% 	      \begin{itemize}
% 		      \item Key goal: make Welkin's syntax fully decidable and efficient to parse. An important component of CFLT called the Semantics Lifting Lemma (TBD) essentially says we can embed a complex syntax into a semantics. (This proof will hopefully be constructive and work for any random syntax, no matter how crazy it might be). In other words, using an efficient parser does NOT limit how expressive Welkin is.
% 		      \item Presuming the result above, there will be two variants: the finite (regex) and full versions.
% 		            \begin{itemize}
% 			            \item The finite, or regex, version is purely for regex-definable files.
% 			            \item The full version will be LALR parsed, as it is generally a standard for programming languages. Not only is it efficient (both in speed and memory), but any grammar written in LALR is unambiguous (reference needed!).
% 			            \item Now that the idea of these two versions is solidifed, we need some common terms. Most of these should come from graphviz, but also in other note taking formats.
% 		            \end{itemize}
% 		      \item The standard format should read just like an ordinary programming language. It may be akin to graphviz, but it should prioritze on the contents of each node and edge, not necessarially how they are rendered. (A better thought would be to put rendering information in a standard \textit{library}, which could then be minimized when browsing through a Welkin file/project.)
% 		            \begin{itemize}
% 			            \item Welkin essentially needs the key elements from set theory: conjunction, disjunction, negation, implication, etc. We can use corresponding symbols for these: $\&\&, ||, \neg, \rightarrow$. In \textit{customizable files}, these symbols can be overloaded and added upon.
% 			            \item Key goal: make this FULLY compatible with dot. (In fact, for a prototype, we can work with dot directly, but we should make it helpful for our needs).
% 									\item Another important point: we want to say that graph ALWAYS refers to a metagraph (to avoid redundancy)		            \end{itemize}
% 	      \end{itemize}
% 	\item Following CFLT, explain a suitable semantics for Welkin.
% 	      \begin{itemize}
% 		      \item We need to determine how to implement all of the axioms.
% 		      \item We also need to use a suitable proof system (e.g., Hilbert, Gentzen, etc.). Maybe that could be decided in CFLT?
% 	      \end{itemize}
% \end{itemize}
% TODO: figure out how to handle references to self. Is a separate keyword 'self' needed?
%\renewcommand{\syntleft}{\normalfont\bfseries}
%\renewcommand{\syntright}{}

% TODO: directly convert this into other grammars, such as lark.
% There should be some consistent procedure to ensure that the BNF here
% is the same as those found in any implementation
% Interesting idea: when there is a node A that should connect to other nodes B_1, B_2, ..., B_n,
% we require that the latter nodes be wrapped in their own graph. That way, we can stay consistent with
% GraphViz notation (for possible compatiblity reasons), but at the same time, we can keep track of the out-neighbors (out going
%\renewcommand{\bnfexpr}{\textbf}
\subsubsection*{Syntax}
\begin{bnfgrammar}
	terms ::= term*
	;;
	term ::= graph || connection || ident || string || num ;;
	graph ::= <graph ident>? `\{' terms `\}';;
	<graph ident> ::= ident || string ;;
	connection ::= term connector term ;;
	connector ::= edge | <left arrow> | <right arrow> ;;
	edge ::= `-' term `-' ;;
	<left arrow> ::= `-' term `->' ;;
	<right arrow> ::= `<-' term `-' ;;
	ident ::= CHAR* ;;
	num ::= NUMBER* ;;
	string ::= [``] CHAR\* [''] || [`] CHAR\* [']
\end{bnfgrammar}


% TODO: the slashes quotes above should be slashes, and then quotes. We need to fix this!
Base Welkin is given by the grammar in Figure ??. Note that if $\numbers= \emptyset,$ any instances of the rule num must be excluded from the parser. This grammar defines the text-based interface to the Welkin Information Graph (see Subsection 2.? for more details).
% TODO: recognize, in cflt, that the above welkin file is in fact a context free grammar! The more important part, which we need to still define, is the semantics, which will have its full strength with the full grammar. (Maybe we should change that option to be semantics instead?)

\subsubsection*{Semantics}
We first form an Abstract Syntax Tree (AST), from which we form the final stored data in a \textbf{Encoded Welkin Information Graph.}
% TODO: talk about encoding of numbers. This probably a separate encoding from the one used to write the welkin file
\begin{definition}
	A \textbf{Welkin Information Graph (WIG)} is a tuple $G = (V, E, A),$ where
	\begin{itemize}
		\item $V$ is a set of \textbf{vertices} or \textbf{units,}
		\item $E \subseteq V^{2} $ is a set of \textbf{directed edges,}
		\item $A: \chars* \to V \cup E$ is an \textbf{alias function.}
	\end{itemize}
\end{definition}

\begin{lemma}
The conversion from ASTs to Welkin Information Graphs is valid.
\end{lemma}


The

e section ``Graph Application Behavior'' for more details. For subsequent chapter, we refer to the file above as \textbf{-config.}


\section{General Application Behavior}


\subsection{Customization}
All Welkin files are infinitely customizable via the welkin config file, which is written in standard welkin.

Every .welkin file has a corresponding configuration. It may either be put as a comment or (preferred) written in a separate file, which, by default, is called config.welkin. It has the following format:
% TODO: replace itemzie with listing
% TODO: decide how to work with a folder (or folders) of config files
\begin{itemize}
	\item Encoding
				\begin{itemize}
					% TODO: list major ascii versions/varieties. Need an official reference for this!
					\item Options: ascii, utf-8, utf-16, other
					\item In the case of other: we need to specify how to define an encoding. (We need a light-weight API for implementations)
				\end{itemize}
	\item Grammar
				\begin{itemize}
					\item Strength: bounded (only finitely nested graphs with a given nesting limit, no recursion), no-self (arbitrary nesting limit, but no recursion), full (recursion allowed)
					\item Customized: use a builtin template or custom welkin file. These can be used to change any part of the grammar, including adding keywords, the symbols used, adding new symbols, etc. Essentially, this will be a way to built new grammars from the original specification; we will need a separate parser for this (i.e., a parser of BNF/Welkin accepted notation).
				\end{itemize}

	\item (Optional) Language
				\begin{itemize}
					\item Defaults to English. Can be written in the writer's desired language (as long as it has been configured in Encoding above)
				\end{itemize}
\end{itemize}

Alternatively, a file with a different name may be used; see th


\begin{quote}{\ttfamily \raggedright \noindent
	term -> \{ graph connection ident string\}\\
	graph -> \{\{ident \{\}\}->`\{'--term--`\}'\}\\
	connection -> \{term--connector--term\}\\
	connector -> \{edge arrow\}\\
	edge -> `--'\\
	arrow -> `->'\\
	ident -> CHAR*\\
	string -> ``'' CHAR* ``'' | `\`' CHAR* `\''
}\end{quote}

\section{Core Algorithms}

\subsection{Graph Encoding}



\label{ch:spec}
