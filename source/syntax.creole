= Syntax =

This section introduces the Welkin grammar.

* First, we recursively define regular expressions. We proceed to define finite proofs.
* Next, we define terminals and present our conventions on grammars.
* Finally, we present the grammars for Welkin texts and encodings solely with regular expressions, ensuring that these grammars are completely specified.

All symbols within this theory are written in `typewriter` font.

== Derivation ==

We introduce three symbols:
* Two **variables**: `A` and `S`.
** `R` is the **rule symbol**.
** `S` is the **start symbol**.
* The **derivation operator** `->`.

We concatenate symbols in each rule and proof of this document. 

Derivation is recursively defined by two rules:

* (DB) `R` is a derivation.
* (DR) If `S` is a derivation, then `R -> S` is a derivation.

We return to practical restrictions of (DR) in Section ?.?.

== Bits ==

Along with derivation, we introduce five symbols.

* There are two symbols called **bits**: `0` and `1`.
* There are two symbols called **variables**: `b` and `b+`.
** `b` is a **bit**.
** `b+` is a **word**.

Regular expressions for bits have the following four rules:
* (B0) `b.0`
* (B1) `b.1`
* (B+A) `A.b+`
* (B+B) `b+ -> b`
* (B+I) `b.b+`

A **byte** consists of eight bits: `bbbbbbbb`.

=== Hash Certificates ===

To faciliiate finding proofs, we intentionally allow
rule (DR) to be unbounded. However, to verify a proof in a fixed, finite time,
we introduce a hash function as follows: 

Practically, we set our parameter to include **100 bits**. Choosing a specific
number is important for standardization. However,
this value can easily be adjusted to be larger, extending
the proofs that can be verified with 100 bits.

== ASCII ==

ASCII (American Standard Code for Information Interchange) consists of 256 characters. Historically, the first 32 characters were used for printing. For the purposes of this standard, we define the ASCII character set to include only the usual printable US-ASCII characters, along with four control characters to support text files. However, this set of characters may be extended using character encodings; see Section ?.?.

**Definition.** A **character in ASCII** is either:
* A byte `001bbbbb`
* A byte `01bbbbb0`
* One of four control characters:
** `00001001` (TAB)
** `00001010` (LF)
** `00001011` (VT) 
** `00001101` (CR)

We divide ASCII characters into five different groups, displayed in Tables ?.?-?.?. We write each printable character using a symbol called a **glyph**, as well the representation of all symbols used in this Standard. 

**Definition (Character Groups)**
* A **layout** character is a space or one of the control characters. (Table ?.1)
* A **digit** is one of `0 1 2 3 4 5 6 7 8 9`. (Table ?.2)
* **Letters** consist of
** Upper case: `A B C D E F G H I J K L M N O P Q R S T U V W X Y Z` (Table ?.3)
** Lower case: `a b c d e f g h i j k l m n o p q r s t u v w x y z` (Table ?.4)
* **Punctuation** is one of . (Table ?.5)

** Table ?.1: Layout Characters **
|=Binary   |=Glyph  | =Representation |=Description|
| 00100000 |        |            | |
| 00100000 |        |            | 
| 00100001 |        |            |


| 00100010 |        |            |
| 00100011 |        |            |
| 00100100 |        |            |
| 00100101 |        |            |
| 00100110 |        |            |
| 00100111 |        |            |


We write any sequence of ASCII characters in double quotes `""`. Every ASCII character is manually converted to binary in Section Bootstrap. 

== Terminals == 
* Strings use either single or double quotes. We separate both definitions for clarity.

== Character Encodings ==

In order to support character encodings broadly, we define the following.

**Definition.** Let `c` be a new symbol. A (character) **encoding** `E` is a sequence of bytes separated by `c`: `(b+c)+`. In other words, encodings
are defined by two rules:
* (E+B) `(b+.c)+ -> b+.c`
* (E+I) `(b+.c).(b+.c)+`

**Definition. (Interpretation into US-ASCII)**

== Grammar ==

This section provides an informal overview of the Welkin grammar.
Although each term in our EBNF is carefully defined, EBNF
is a separate, independent language that, if not done carefully,
may introduce ambiguities. To avoid any possible confusion,
the full grammar and its notation is embedded into the Bootstrap.

We use the following notation.
* Productions include lower-case characters and can
end with "?".
* Spacing:
** Two nonterminals separated by a space can have any number of whitespace characters.
** Two nonterminals combined with "." have no characters inbetween them.


The Welkin grammar is given in Table ?.?.

{{{
    start: term "," start end | empty
    term: graph chain
    chain: link graph? link | empty
    link: ""<-" | "->" | "-"
    graph?: graph | empty
    graph: name contents? | contents
    name?: name | empty
    name: import.unit.path
    contents?: contents | empty
    contents: "{" term "}"
    import: ".".dots | empty
    dots: ".".dots | empty
    path: ".".unit.path
    unit: string | identifier
    string: STRING
    identifier: IDENTIFIER
    end: "," | empty
}}}

For the encoding, see the regular expression in Section 3.?.

=== Unambiguity ===

This section informally demonstrates that the Welkin grammar is unambiguous. For proofs of all claims made here, 
see Section `Bootstrap`. We present an informal proof here.

Following (), we calculate the first and follow sets for the grammar.
As there are no first and follow set collisions, this grammar is LL(1), 
and hence is unambiguous. (The regular expressions used in unit can be expressed in LL(1) grammars, and can thus be concatenated with the rest of the grammar.)
