= Syntax =

This section introduces the Welkin grammar. In order
to avoid ambiguities in this document, we first
introduce regular expressions. We then write down
the grammars for Welkin texts and encodings
solely with regular expressions,
ensuring that these grammars are
completely specified.

We define proofs separately for each definition.
We then show these combine into a
broader definition.

== Regular Expressions ==

We leave several notions undefined. These notions
must follow the rules described in this document.

* There are two symbols called **bits**: `0` and `1`.
** (FIX) A bit is denoted by `(0|1)`.
* There is an operation called **concatenation**, denoted by `.`.

A **byte** is `(0|1).(0|1).(0|1).(0|1).(0|1).(0|1).(0|1).(0|1)`.

A **character in US-ASCII** is a byte starting with `0`:

`0.(0|1).(0|1).(0|1).(0|1).(0|1).(0|1).(0|1)`.

Each character **encodes** (assigns to a) unique symbol. Table ?.?
provides the US-ASCII encoding. For an unambiguous interpretation,
see [[source/bootstrap.creole|Bootstrap]].

|=symbol|=character|
|    a  |          |


**Lemma.** '-->' is a byte.


== Terminals == 

A **word** is recursively defined.

* Basis (5):
** `0` is a word.
** `1` is a word.
* Recursion (6): let `w` be a word.
** `w.0` (written w0) is a word.
** `w.1` (written w1) is a word.


** Lemma.** A byte is a word.
// Proof. // 


* A **layout** character is

== Atoms ==
* Strings are words delimited with either single quotes `'` or double quotes `"`.
  More precisely, if `w` is a word without quotes, then:
** `'w'` is a string.
** `"w"` is a stirng.
  We say `w` is the **contents** of the string.
* Escaped characters ():
** Every instance of \' in `w` is replaced by '.
** Every instance of \" in `w` is replaced by ".
** Every instance of \\ in `w` is replaced by \\.
* Identifiers are strings without white space.

== Grammar ==
* LL
** Unambiguous
* Welkin Grammar:

